# .github/workflows/build-rn-app.yml
name: Build React Native App

on:
  workflow_dispatch:
    inputs:
      build_id:
        description: 'Build ID'
        required: true
        type: string
      app_name:
        description: 'App Name'
        required: true
        type: string
      build_type:
        description: 'Build Type'
        required: false
        default: 'release'
        type: choice
        options:
        - release
        - debug
      output_type:
        description: 'Output Type'
        required: false
        default: 'apk'
        type: choice
        options:
        - apk
        - aab
      platform:
        description: 'Platform'
        required: false
        default: 'android'
        type: string

jobs:
  build-android:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js 18 with cache
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Setup Java 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Setup Android SDK with cache
      uses: android-actions/setup-android@v3
      with:
        cache-key: android-sdk-${{ runner.os }}
        
    - name: Cache Gradle dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
          
    - name: Cache node_modules
      uses: actions/cache@v4
      with:
        path: node_modules
        key: ${{ runner.os }}-node_modules-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node_modules-

    - name: Read build configuration
      id: config
      run: |
        if [ -f "build-config.json" ]; then
          echo "status=Reading build configuration..." >> $GITHUB_OUTPUT
          
          # Extract values from build-config.json
          WEBSITE_ADDRESS=$(jq -r '.website_address' build-config.json)
          APP_NAME=$(jq -r '.app_name' build-config.json)
          VERSION_CODE=$(jq -r '.version_code' build-config.json)
          VERSION_NAME=$(jq -r '.version_name' build-config.json)
          NAME_SPACE=$(jq -r '.name_space' build-config.json)
          BUILD_TYPE=$(jq -r '.buildType' build-config.json)
          OUTPUT_TYPE=$(jq -r '.outputType' build-config.json)
          APP_ICON=$(jq -r '.app_icon' build-config.json)
          BUILD_ID=$(jq -r '.buildId' build-config.json)
          HAS_CUSTOM_ICON=$(jq -r '.has_custom_icon' build-config.json)
          
          # Set environment variables
          echo "WEBSITE_ADDRESS=$WEBSITE_ADDRESS" >> $GITHUB_ENV
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          echo "VERSION_CODE=$VERSION_CODE" >> $GITHUB_ENV
          echo "VERSION_NAME=$VERSION_NAME" >> $GITHUB_ENV
          echo "NAME_SPACE=$NAME_SPACE" >> $GITHUB_ENV
          echo "BUILD_TYPE=$BUILD_TYPE" >> $GITHUB_ENV
          echo "OUTPUT_TYPE=$OUTPUT_TYPE" >> $GITHUB_ENV
          echo "APP_ICON=$APP_ICON" >> $GITHUB_ENV
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV
          echo "HAS_CUSTOM_ICON=$HAS_CUSTOM_ICON" >> $GITHUB_ENV
          
          echo "Configuration loaded successfully"
          echo "Custom icon provided: $HAS_CUSTOM_ICON"
        else
          echo "status=No build config found, using workflow inputs" >> $GITHUB_OUTPUT
          echo "APP_NAME=${{ github.event.inputs.app_name }}" >> $GITHUB_ENV
          echo "BUILD_TYPE=${{ github.event.inputs.build_type }}" >> $GITHUB_ENV
          echo "OUTPUT_TYPE=${{ github.event.inputs.output_type }}" >> $GITHUB_ENV
          echo "BUILD_ID=${{ github.event.inputs.build_id }}" >> $GITHUB_ENV
          echo "HAS_CUSTOM_ICON=false" >> $GITHUB_ENV
        fi
        
    - name: Install dependencies
      run: |
        echo "status=Installing npm dependencies..." >> $GITHUB_OUTPUT
        # Use ci for faster, reliable installs
        npm ci --no-audit --no-fund --prefer-offline
        
    - name: Apply template customizations
      shell: bash
      run: |
        echo "status=Applying template customizations..." >> $GITHUB_OUTPUT

        # Defaults
        WEBSITE_ADDRESS=${WEBSITE_ADDRESS:-"https://example.com"}
        APP_NAME=${APP_NAME:-"MyApp"}
        VERSION_CODE=${VERSION_CODE:-"1"}
        VERSION_NAME=${VERSION_NAME:-"1.0.0"}
        NAME_SPACE=${NAME_SPACE:-"com.myapp.example"}

        echo "App Name: $APP_NAME"
        echo "Namespace: $NAME_SPACE"
        echo "Version: $VERSION_NAME ($VERSION_CODE)"

        # Middle segment for template folder names
        MIDDLE_SEGMENT=$(echo "$NAME_SPACE" | cut -d'.' -f2)
        if [ -z "$MIDDLE_SEGMENT" ]; then
          MIDDLE_SEGMENT=$(echo "$NAME_SPACE" | awk -F. '{print $NF}')
        fi
        echo "Middle segment: $MIDDLE_SEGMENT"

        # Escape replacements for sed: escape \, /, &
        esc() { printf '%s' "$1" | sed -e 's/[\\/&]/\\&/g'; }

        WEBSITE_ADDRESS_ESC=$(esc "$WEBSITE_ADDRESS")
        APP_NAME_ESC=$(esc "$APP_NAME")
        VERSION_CODE_ESC=$(esc "$VERSION_CODE")
        VERSION_NAME_ESC=$(esc "$VERSION_NAME")
        NAME_SPACE_ESC=$(esc "$NAME_SPACE")
        MIDDLE_SEGMENT_ESC=$(esc "$MIDDLE_SEGMENT")

        # Apply replacements in parallel, using | as delimiter
        export WEBSITE_ADDRESS_ESC APP_NAME_ESC VERSION_CODE_ESC VERSION_NAME_ESC NAME_SPACE_ESC MIDDLE_SEGMENT_ESC
        find . -type f \( -name "*.gradle" -o -name "*.json" -o -name "*.xml" -o -name "*.tsx" -o -name "*.kt" \) -print0 \
        | xargs -0 -P 4 -I {} bash -c '
          sed -i \
            -e "s|rn_project_template|$MIDDLE_SEGMENT_ESC|g" \
            -e "s|{{website_address}}|$WEBSITE_ADDRESS_ESC|g" \
            -e "s|{{app_name}}|$APP_NAME_ESC|g" \
            -e "s|{{version_code}}|$VERSION_CODE_ESC|g" \
            -e "s|{{version_name}}|$VERSION_NAME_ESC|g" \
            -e "s|com\.rn_project_template|$NAME_SPACE_ESC|g" \
            -e "s|{{name_space}}|$NAME_SPACE_ESC|g" \
            "{}"
        '

        # Restructure Java/Kotlin package directories
        echo "Restructuring Java packages..."
        OLD_JAVA_PATH="android/app/src/main/java/com/rn_project_template"
        NEW_JAVA_PATH="android/app/src/main/java/$(echo "$NAME_SPACE" | tr "." "/")"
        if [ -d "$OLD_JAVA_PATH" ]; then
          mkdir -p "$(dirname "$NEW_JAVA_PATH")"
          mv "$OLD_JAVA_PATH" "$NEW_JAVA_PATH"
          find android/app/src/main/java/com -type d -empty -delete 2>/dev/null || true
          echo "Moved Java files from $OLD_JAVA_PATH to $NEW_JAVA_PATH"
        fi

        
    - name: Install Sharp for icon processing
      if: env.HAS_CUSTOM_ICON == 'true' && env.APP_ICON != '' && env.APP_ICON != 'null'
      run: |
        echo "status=Installing Sharp for image processing..." >> $GITHUB_OUTPUT
        # Install sharp for image processing
        npm install sharp --no-save --silent
        
    - name: Process custom app icon
      if: env.HAS_CUSTOM_ICON == 'true' && env.APP_ICON != '' && env.APP_ICON != 'null'
      run: |
        echo "status=Processing custom app icon..." >> $GITHUB_OUTPUT
        
        # Create optimized Node.js script to process icon
        cat > process_icon.js << 'EOF'
        const sharp = require('sharp');
        const fs = require('fs');
        const path = require('path');
        
        async function generateIcons() {
          try {
            const iconData = process.env.APP_ICON;
            
            if (!iconData || iconData === 'null') {
              console.log('No app icon provided');
              return;
            }
            
            console.log('Processing app icon...');
            
            let iconBuffer;
            
            // Validate and extract base64 data
            if (iconData.startsWith('data:image/')) {
              const matches = iconData.match(/^data:image\/(\w+);base64,(.+)$/);
              if (!matches) {
                throw new Error('Invalid data URL format');
              }
              
              const [, imageType, base64Data] = matches;
              console.log(`Image type: ${imageType}`);
              
              if (!['png', 'jpeg', 'jpg', 'gif', 'webp'].includes(imageType.toLowerCase())) {
                throw new Error(`Unsupported image type: ${imageType}`);
              }
              
              iconBuffer = Buffer.from(base64Data, 'base64');
              console.log(`Icon buffer size: ${iconBuffer.length} bytes`);
            } else {
              throw new Error('App icon must be a base64 data URL');
            }
            
            // Verify the image can be processed
            const metadata = await sharp(iconBuffer).metadata();
            console.log(`Original image: ${metadata.width}x${metadata.height} ${metadata.format}`);
            
            if (metadata.width < 48 || metadata.height < 48) {
              throw new Error('Icon too small. Minimum size is 48x48 pixels');
            }
            
            const androidResPath = 'android/app/src/main/res';
            
            // Define all required icon sizes and folders
            const iconConfigs = [
              // Drawable folders (for backward compatibility)
              { size: 36, folder: 'drawable-ldpi', filename: 'ic_launcher.png' },
              { size: 48, folder: 'drawable-mdpi', filename: 'ic_launcher.png' },  
              { size: 72, folder: 'drawable-hdpi', filename: 'ic_launcher.png' },
              { size: 96, folder: 'drawable-xhdpi', filename: 'ic_launcher.png' },
              { size: 144, folder: 'drawable-xxhdpi', filename: 'ic_launcher.png' },
              { size: 192, folder: 'drawable-xxxhdpi', filename: 'ic_launcher.png' },
              
              // Mipmap folders (modern Android)
              { size: 48, folder: 'mipmap-mdpi', filename: 'ic_launcher.png' },
              { size: 72, folder: 'mipmap-hdpi', filename: 'ic_launcher.png' },
              { size: 96, folder: 'mipmap-xhdpi', filename: 'ic_launcher.png' },
              { size: 144, folder: 'mipmap-xxhdpi', filename: 'ic_launcher.png' },
              { size: 192, folder: 'mipmap-xxxhdpi', filename: 'ic_launcher.png' },
              
              // Round icons (Android 7.1+)
              { size: 48, folder: 'mipmap-mdpi', filename: 'ic_launcher_round.png' },
              { size: 72, folder: 'mipmap-hdpi', filename: 'ic_launcher_round.png' },
              { size: 96, folder: 'mipmap-xhdpi', filename: 'ic_launcher_round.png' },
              { size: 144, folder: 'mipmap-xxhdpi', filename: 'ic_launcher_round.png' },
              { size: 192, folder: 'mipmap-xxxhdpi', filename: 'ic_launcher_round.png' },
            ];
            
            // Create all directories first
            const uniqueFolders = [...new Set(iconConfigs.map(config => config.folder))];
            for (const folder of uniqueFolders) {
              const folderPath = path.join(androidResPath, folder);
              if (!fs.existsSync(folderPath)) {
                fs.mkdirSync(folderPath, { recursive: true });
                console.log(`Created folder: ${folderPath}`);
              }
            }
            
            // Process all icons in parallel for speed
            console.log(`Generating ${iconConfigs.length} icon variants...`);
            
            const iconTasks = iconConfigs.map(async ({ size, folder, filename }) => {
              try {
                const outputPath = path.join(androidResPath, folder, filename);
                
                await sharp(iconBuffer)
                  .resize(size, size, {
                    fit: 'cover',
                    position: 'center'
                  })
                  .png({
                    quality: 90,
                    compressionLevel: 6
                  })
                  .toFile(outputPath);
                
                console.log(`✓ Generated ${folder}/${filename} (${size}x${size})`);
                return { success: true, path: outputPath };
              } catch (error) {
                console.error(`✗ Failed to generate ${folder}/${filename}:`, error.message);
                return { success: false, error: error.message };
              }
            });
            
            const results = await Promise.allSettled(iconTasks);
            
            // Check results
            const successful = results.filter(r => r.status === 'fulfilled' && r.value.success).length;
            const failed = results.length - successful;
            
            console.log(`Icon generation complete: ${successful} successful, ${failed} failed`);
            
            if (successful === 0) {
              throw new Error('Failed to generate any icons');
            }
            
            if (failed > 0) {
              console.warn(`Warning: ${failed} icons failed to generate, but ${successful} were successful`);
            }
            
            // Create adaptive icons XML (optional enhancement)
            await createAdaptiveIconXml(androidResPath);
            
            console.log('✅ Custom app icon processing completed successfully!');
            
          } catch (error) {
            console.error('❌ Icon processing failed:', error.message);
            console.error('Stack trace:', error.stack);
            process.exit(1);
          }
        }
        
        // Create adaptive icon XML configuration
        async function createAdaptiveIconXml(androidResPath) {
          try {
            const adaptiveIconsPath = path.join(androidResPath, 'mipmap-anydpi-v26');
            if (!fs.existsSync(adaptiveIconsPath)) {
              fs.mkdirSync(adaptiveIconsPath, { recursive: true });
            }
            
            const adaptiveIconXml = `<?xml version="1.0" encoding="utf-8"?>
        <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
            <background android:drawable="@android:color/white" />
            <foreground android:drawable="@mipmap/ic_launcher" />
        </adaptive-icon>`;
        
            fs.writeFileSync(path.join(adaptiveIconsPath, 'ic_launcher.xml'), adaptiveIconXml);
            fs.writeFileSync(path.join(adaptiveIconsPath, 'ic_launcher_round.xml'), adaptiveIconXml);
            
            console.log('✓ Created adaptive icon configuration');
          } catch (error) {
            console.warn('Warning: Failed to create adaptive icon XML:', error.message);
          }
        }
        
        generateIcons().catch((error) => {
          console.error('Fatal error in icon generation:', error);
          process.exit(1);
        });
        EOF
        
        # Run the icon processing script
        node process_icon.js
        
        # Verify icons were created
        echo "Verifying generated icons..."
        find android/app/src/main/res -name "ic_launcher*.png" -type f | head -10 | while read icon; do
          echo "✓ Found: $icon"
        done
        
    - name: Make gradlew executable
      run: chmod +x android/gradlew
      
    - name: Clean previous builds
      run: |
        echo "status=Cleaning previous builds..." >> $GITHUB_OUTPUT
        cd android
        ./gradlew clean --no-daemon --parallel
        
    - name: Build Android App
      run: |
        echo "status=Building Android application..." >> $GITHUB_OUTPUT
        cd android
        
        BUILD_TYPE=${BUILD_TYPE:-release}
        OUTPUT_TYPE=${OUTPUT_TYPE:-apk}
        
        echo "Building $BUILD_TYPE $OUTPUT_TYPE..."
        if [ "$HAS_CUSTOM_ICON" = "true" ]; then
          echo "Building with custom app icon"
        fi
        
        # Set Gradle arguments based on build type and output type
        if [ "$BUILD_TYPE" = "release" ]; then
          if [ "$OUTPUT_TYPE" = "aab" ]; then
            GRADLE_TASK="bundleRelease"
            BUILT_PATH="app/build/outputs/bundle/release/app-release.aab"
          else
            GRADLE_TASK="assembleRelease"
            BUILT_PATH="app/build/outputs/apk/release/app-release.apk"
          fi
        else
          GRADLE_TASK="assembleDebug"
          BUILT_PATH="app/build/outputs/apk/debug/app-debug.apk"
        fi
        
        echo "Running: ./gradlew $GRADLE_TASK"
        
        # Optimized Gradle settings for faster builds
        export GRADLE_OPTS="-Xmx6g -Dorg.gradle.daemon=false -Dorg.gradle.jvmargs=-Xmx6g -Dorg.gradle.parallel=true -Dorg.gradle.configureondemand=true"
        
        # Run the build with optimizations
        ./gradlew $GRADLE_TASK \
          --stacktrace \
          --no-daemon \
          --parallel \
          --build-cache \
          --configure-on-demand \
          -Dorg.gradle.jvmargs="-Xmx6g -XX:+UseG1GC -XX:+UseStringDeduplication"
          
        echo "Build completed successfully!"
        echo "BUILT_PATH=$BUILT_PATH" >> $GITHUB_ENV
        
    - name: Prepare build artifacts
      run: |
        echo "status=Preparing build artifacts..." >> $GITHUB_OUTPUT
        BUILD_ID="${BUILD_ID:-${{ github.event.inputs.build_id }}}"
        APP_NAME="${APP_NAME:-${{ github.event.inputs.app_name }}}"
        BUILD_TYPE="${BUILD_TYPE:-${{ github.event.inputs.build_type }}}"
        OUTPUT_TYPE="${OUTPUT_TYPE:-${{ github.event.inputs.output_type }}}"
        
        # Create artifacts directory
        mkdir -p artifacts
        
        # Copy built app
        BUILT_FILE="android/${BUILT_PATH}"
        ARTIFACT_NAME="app-${BUILD_TYPE}-${BUILD_ID}.${OUTPUT_TYPE}"
        
        if [ -f "$BUILT_FILE" ]; then
          cp "$BUILT_FILE" "artifacts/$ARTIFACT_NAME"
          echo "Copied $BUILT_FILE to artifacts/$ARTIFACT_NAME"
        else
          echo "Error: Built file not found at $BUILT_FILE"
          ls -la android/app/build/outputs/
          exit 1
        fi
        
        # Create build info
        cat > artifacts/build-info.json << EOF
        {
          "buildId": "$BUILD_ID",
          "appName": "$APP_NAME", 
          "buildType": "$BUILD_TYPE",
          "outputType": "$OUTPUT_TYPE",
          "platform": "android",
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "versionCode": "${VERSION_CODE:-1}",
          "versionName": "${VERSION_NAME:-1.0.0}",
          "namespace": "${NAME_SPACE:-com.example.app}",
          "fileSize": "$(stat -c%s "artifacts/$ARTIFACT_NAME")",
          "fileName": "$ARTIFACT_NAME",
          "hasCustomIcon": "${HAS_CUSTOM_ICON:-false}"
        }
        EOF
        
        echo "Build artifacts prepared successfully"
        ls -la artifacts/
        echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}
        
    - name: Upload to AWS S3
      run: |
        echo "status=Uploading artifacts to AWS S3..." >> $GITHUB_OUTPUT
        
        BUILD_ID="${BUILD_ID:-${{ github.event.inputs.build_id }}}"
        S3_BUCKET="${{ secrets.AWS_S3_BUCKET }}"
        S3_PREFIX="builds/${BUILD_ID}"
        
        if [ -z "$S3_BUCKET" ]; then
          echo "Error: AWS_S3_BUCKET secret not configured"
          exit 1
        fi
        
        # Upload all artifacts to S3
        aws s3 cp artifacts/ s3://${S3_BUCKET}/${S3_PREFIX}/ --recursive
        
        # Generate presigned URLs (valid for 7 days)
        APP_DOWNLOAD_URL=$(aws s3 presign s3://${S3_BUCKET}/${S3_PREFIX}/${ARTIFACT_NAME} --expires-in 604800)
        INFO_DOWNLOAD_URL=$(aws s3 presign s3://${S3_BUCKET}/${S3_PREFIX}/build-info.json --expires-in 604800)
        
        echo "APP_DOWNLOAD_URL=$APP_DOWNLOAD_URL" >> $GITHUB_ENV
        echo "INFO_DOWNLOAD_URL=$INFO_DOWNLOAD_URL" >> $GITHUB_ENV
        
        echo "✅ Successfully uploaded to S3: s3://${S3_BUCKET}/${S3_PREFIX}/"
        
    - name: Update build status
      if: always()
      run: |
        BUILD_ID="${BUILD_ID:-${{ github.event.inputs.build_id }}}"
        S3_BUCKET="${{ secrets.AWS_S3_BUCKET }}"
        
        if [ "${{ job.status }}" = "success" ]; then
          STATUS="completed"
          CONCLUSION="success"
          if [ "$HAS_CUSTOM_ICON" = "true" ]; then
            MESSAGE="Build completed successfully with custom app icon and uploaded to S3"
          else
            MESSAGE="Build completed successfully and uploaded to S3"
          fi
        else
          STATUS="completed"  
          CONCLUSION="failure"
          MESSAGE="Build failed - check logs for details"
        fi
        
        # Create status file
        cat > build-status.json << EOF
        {
          "buildId": "$BUILD_ID",
          "status": "$STATUS",
          "conclusion": "$CONCLUSION", 
          "message": "$MESSAGE",
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "downloadUrl": "${APP_DOWNLOAD_URL:-null}",
          "infoUrl": "${INFO_DOWNLOAD_URL:-null}",
          "repoUrl": "${{ github.server_url }}/${{ github.repository }}",
          "hasCustomIcon": "${HAS_CUSTOM_ICON:-false}"
        }
        EOF
        
        # Upload status to S3
        if [ -n "$S3_BUCKET" ]; then
          aws s3 cp build-status.json s3://${S3_BUCKET}/status/${BUILD_ID}.json
          echo "Status uploaded to S3"
        fi
        
    - name: Cleanup and delete repository
      if: always()
      run: |
        echo "status=Cleaning up and deleting repository..." >> $GITHUB_OUTPUT
        
        # The repository will be deleted by the calling API after this workflow completes
        # This step is just for logging
        echo "Repository cleanup will be handled by the API caller"
        
        if [ "${{ job.status }}" = "success" ]; then
          echo "✅ Build completed successfully!"
          echo "App: ${{ github.event.inputs.app_name }}"
          echo "Build ID: ${{ github.event.inputs.build_id }}"
          echo "Type: ${{ github.event.inputs.build_type }} ${{ github.event.inputs.output_type }}"
          if [ "$HAS_CUSTOM_ICON" = "true" ]; then
            echo "Custom app icon: Applied successfully"
          fi
          echo "Files uploaded to S3 successfully"
        else
          echo "❌ Build failed!"
          echo "Check the logs above for error details."
        fi
